Of course. I've analyzed and rewritten the code to resolve the errors you're facing.

The "unexpected error" during analysis was caused by a missing helper function that is required to process images before sending them to the AI. The issue with deleting profiles is not a bug in the code itself, but a permissions problem in your Firebase database which I'll show you how to fix.

### Summary of Fixes

1.  **Analysis Error Corrected:** The primary bug was a missing function called `resizeAndEncodeImage`. The code was trying to use it to prepare your uploaded photos for the AI, but it was never defined, causing the process to crash. I have written and included this necessary function.
2.  **Deletion Error Explained:** The reason you can't delete profiles is that your Firestore database's security rules are, by default, too restrictive. They prevent any user from deleting data. The provided JavaScript is correct, but it's being blocked by the backend. **You must update your Firestore rules** in the Firebase console for deletion to work.
3.  **Improved Robustness:** I've made the measurement calculation logic more resilient. It will no longer crash if the AI model fails to identify one of the measurement points on the images.
4.  **Code Cleanup:** The event listeners for both "Sign Out" buttons have been consolidated for cleaner code.

-----

### 1\. Update Your Firestore Rules

Before using the updated code, go to your **Firebase project \> Firestore Database \> Rules** and replace the default rules with the following. This is a **required step** for saving and deleting profiles.

```javascript
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Allow authenticated users to read, write, and delete their own profiles.
    match /artifacts/body-measurement-app/users/{userId}/profiles/{profileId} {
      allow read, write, delete: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

-----

### 2\. Fully Corrected Code

Here is the complete `index.html` file with all the errors fixed and improvements implemented. You can replace the entire content of your file with this.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Body Measurement Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .screen { display: none; }
        .active { display: flex; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .calibration-canvas.active-canvas {
            border: 3px solid #4f46e5;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.7);
            cursor: crosshair;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">

    <div id="app-container" class="w-full max-w-6xl mx-auto bg-gray-800 rounded-2xl shadow-2xl overflow-hidden relative pb-12">

        <div id="loading-screen" class="screen active flex-col items-center justify-center h-[80vh]">
            <div class="loader"></div>
            <p class="mt-4 text-lg text-gray-400">Initializing AI Analysis Engine...</p>
        </div>

        <div id="login-screen" class="screen flex-col items-center justify-center h-[80vh] p-8 text-center">
            <h1 class="text-5xl font-bold text-white mb-4">Body Composition AI</h1>
            <p class="text-xl text-gray-400 mb-12 max-w-2xl">Sign in with your Google account to save and manage your personal body measurement profiles.</p>
            <button id="google-login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105 shadow-lg flex items-center gap-3">
                <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"></path><path fill="#FF3D00" d="M6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"></path><path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.222 0-9.519-3.487-11.181-8.264l-6.522 5.025C9.505 39.556 16.227 44 24 44z"></path><path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C42.012 36.49 44 30.638 44 24c0-1.341-.138-2.65-.389-3.917z"></path></svg>
                Sign In with Google
            </button>
        </div>

        <div id="profile-dashboard-screen" class="screen flex-col items-center justify-start h-auto min-h-[80vh] p-8">
             <div class="w-full max-w-3xl">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-3xl font-bold">Your Profiles</h2>
                    <button class="sign-out-btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-sm flex items-center gap-2">
                        <i data-lucide="log-out"></i> Sign Out
                    </button>
                </div>
                <button id="go-to-new-profile-from-dashboard" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg mb-6">
                    + Add New Profile
                </button>
                <div id="profile-list" class="space-y-3"></div>
            </div>
        </div>

        <div id="new-profile-screen" class="screen flex-col items-center justify-center h-auto p-8">
            <div class="w-full max-w-lg">
                <button id="back-to-dashboard-from-new" class="mb-6 text-gray-400 hover:text-white flex items-center gap-2">
                    <i data-lucide="arrow-left"></i> Back to Profiles
                </button>
                <h2 class="text-3xl font-bold mb-6 text-center">Create New Profile</h2>
                <form id="new-profile-form" class="space-y-4">
                    <input type="text" id="name" placeholder="Name" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" required>
                    <input type="text" id="sports" placeholder="Primary Sport" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <input type="text" id="country" placeholder="Country" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    <select id="gender" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" required>
                        <option value="" disabled selected>Select Gender</option>
                        <option value="Male">Male</option>
                        <option value="Female">Female</option>
                    </select>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        <input type="number" id="height" placeholder="Height (cm)" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" required step="any">
                        <input type="number" id="weight" placeholder="Weight (kg)" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" required step="any">
                        <input type="number" id="shoulderWidth" placeholder="Shoulder Width (cm)" class="w-full p-3 bg-gray-700 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" required step="any">
                    </div>
                    <button type="submit" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg mt-4">Save and Continue</button>
                </form>
            </div>
        </div>

        <div id="main-analysis-screen" class="screen flex-col lg:flex-row p-8 gap-8 h-auto min-h-[80vh]">
            <div class="w-full lg:w-1/3 space-y-6">
                 <div class="flex justify-between items-center">
                    <button id="back-to-dashboard-from-main" class="text-gray-400 hover:text-white flex items-center gap-2"><i data-lucide="arrow-left"></i> Back to Profiles</button>
                    <button class="sign-out-btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-sm flex items-center gap-2"><i data-lucide="log-out"></i> Sign Out</button>
                </div>
                <div class="bg-gray-700 p-6 rounded-xl shadow-lg">
                    <h3 class="text-2xl font-bold mb-4">Profile Details</h3>
                    <div id="profile-display" class="space-y-2 text-gray-300"></div>
                </div>
                <div class="bg-gray-700 p-6 rounded-xl shadow-lg">
                    <h3 class="text-2xl font-bold mb-4">Upload Images</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="front-image" class="block mb-1 font-semibold text-gray-300">Front View</label>
                            <input type="file" id="front-image" accept="image/jpeg, image/png" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
                        </div>
                        <div>
                            <label for="side-image" class="block mb-1 font-semibold text-gray-300">Side View</label>
                            <input type="file" id="side-image" accept="image/jpeg, image/png" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
                        </div>
                        <div>
                            <label for="back-image" class="block mb-1 font-semibold text-gray-300">Back View</label>
                            <input type="file" id="back-image" accept="image/jpeg, image/png" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 cursor-pointer">
                        </div>
                    </div>
                </div>
                 <button id="start-calibration-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-6 rounded-lg text-xl flex items-center justify-center gap-3"><i data-lucide="scan-line"></i> Start Calibration</button>
            </div>

            <div class="w-full lg:w-2/3">
                 <div id="calibration-instructions" class="bg-indigo-900/50 p-4 rounded-lg text-center mb-4 hidden">
                    <div class="flex justify-between items-center">
                        <div class="text-left">
                            <p class="text-lg font-semibold">Current Task: <span id="calibration-task-name" class="text-yellow-300"></span></p>
                            <p class="text-sm text-gray-400">Click and drag to draw a line on the highlighted image.</p>
                        </div>
                        <button id="redraw-last-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-3 rounded-lg text-sm flex items-center gap-2"><i data-lucide="undo-2"></i> Redraw Last</button>
                    </div>
                </div>
                <div id="image-previews" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-gray-700 rounded-xl aspect-w-3 aspect-h-4 flex items-center justify-center relative">
                        <img id="front-preview" src="https://placehold.co/300x400/1F2937/4B5563?text=Front+View" alt="Front Preview" class="object-contain w-full h-full rounded-xl">
                        <canvas id="front-calibration-canvas" class="calibration-canvas absolute top-0 left-0 w-full h-full"></canvas>
                    </div>
                    <div class="bg-gray-700 rounded-xl aspect-w-3 aspect-h-4 flex items-center justify-center relative">
                        <img id="side-preview" src="https://placehold.co/300x400/1F2937/4B5563?text=Side+View" alt="Side Preview" class="object-contain w-full h-full rounded-xl">
                        <canvas id="side-calibration-canvas" class="calibration-canvas absolute top-0 left-0 w-full h-full"></canvas>
                    </div>
                    <div class="bg-gray-700 rounded-xl aspect-w-3 aspect-h-4 flex items-center justify-center relative">
                        <img id="back-preview" src="https://placehold.co/300x400/1F2937/4B5563?text=Back+View" alt="Back Preview" class="object-contain w-full h-full rounded-xl">
                        <canvas id="back-calibration-canvas" class="calibration-canvas absolute top-0 left-0 w-full h-full"></canvas>
                    </div>
                </div>
                <div id="analysis-loader-container" class="bg-gray-700 p-6 rounded-xl shadow-lg hidden flex-col items-center justify-center h-full">
                    <div class="loader"></div>
                    <p id="analysis-status-text" class="mt-4 text-lg text-gray-400">AI is generating your report...</p>
                </div>
            </div>
        </div>
        
        <div id="report-screen" class="screen flex-col h-auto min-h-[80vh] p-8 space-y-6">
            <div class="w-full max-w-5xl mx-auto">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-4xl font-bold">Analysis Report</h2>
                    <button id="back-to-main-from-report" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg text-sm flex items-center gap-2"><i data-lucide="arrow-left"></i> Back to Analysis</button>
                </div>
                <section>
                    <h3 class="text-2xl font-semibold mb-4 mt-6">Measurements</h3>
                    <div id="results-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center"></div>
                </section>
                <div id="in-depth-analysis-section" class="space-y-6">
                    <button id="get-in-depth-analysis-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg">Get In-Depth AI Analysis</button>
                    <div id="in-depth-loader" class="hidden flex-col items-center justify-center"><div class="loader"></div><p class="mt-2 text-gray-400">Generating analysis...</p></div>
                    <div id="in-depth-content" class="hidden space-y-6">
                        <section>
                            <h3 class="text-2xl font-semibold mb-4 mt-6">Body Type Analysis</h3>
                            <div class="bg-gray-700 p-6 rounded-lg">
                                <h4 id="body-type-title" class="text-xl font-bold text-indigo-400 mb-2"></h4>
                                <p id="body-type-description" class="text-gray-300"></p>
                            </div>
                        </section>
                        <section>
                            <h3 class="text-2xl font-semibold mb-4 mt-6">Sports Recommendations</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="bg-gray-700 p-6 rounded-lg">
                                    <h4 class="text-xl font-bold text-green-400 mb-2">Recommended Sports</h4>
                                    <ul id="recommended-sports-list" class="list-disc list-inside text-gray-300 space-y-1"></ul>
                                </div>
                                <div class="bg-gray-700 p-6 rounded-lg">
                                    <h4 class="text-xl font-bold text-yellow-400 mb-2">Sports to Approach with Caution</h4>
                                    <ul id="caution-sports-list" class="list-disc list-inside text-gray-300 space-y-1"></ul>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </div>
        
        <footer class="absolute bottom-0 left-0 right-0 p-4 text-center text-gray-500 text-sm">
            Made by <a href="https://www.linkedin.com/in/satya-kulthe/" target="_blank" class="text-indigo-400 hover:underline">Satya Kulthe</a>
        </footer>
    </div>

    <div id="custom-modal" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden items-center justify-center p-4">
        <div class="bg-gray-700 p-8 rounded-2xl shadow-xl max-w-sm w-full text-center border border-gray-600">
            <p id="modal-message" class="mb-6 text-lg">Message goes here.</p>
            <div id="modal-buttons" class="flex justify-center gap-4">
                 <button id="modal-close-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-8 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, query, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBjU3yOJUIrN_cWsSdjyV067jWLGPsjHUI",
            authDomain: "body-analyser8860.firebaseapp.com",
            projectId: "body-analyser8860",
            storageBucket: "body-analyser8860.appspot.com",
            messagingSenderId: "412432296504",
            appId: "1:412432296504:web:481c0ccd99e0f1645414cd",
            measurementId: "G-6YF20DVRZE"
        };
        
        // !!! IMPORTANT SECURITY WARNING !!!
        // DO NOT expose your secret API keys in client-side code in a real application.
        // This key can be stolen and used by others, leading to unexpected charges.
        // For production, use a backend service (like a Cloud Function) to make API calls.
        const GEMINI_API_KEY = "YOUR_GEMINI_API_KEY_HERE";

        // --- App State ---
        let app, db, auth, userId;
        let currentProfile = null;
        let calibrationState = {};
        let lastCalculatedMeasurements = null;
        
        // --- DOM Elements ---
        const screens = {
            loading: document.getElementById('loading-screen'),
            login: document.getElementById('login-screen'),
            dashboard: document.getElementById('profile-dashboard-screen'),
            newProfile: document.getElementById('new-profile-screen'),
            main: document.getElementById('main-analysis-screen'),
            report: document.getElementById('report-screen'),
        };
        const modal = document.getElementById('custom-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalButtons = document.getElementById('modal-buttons');
        const newProfileForm = document.getElementById('new-profile-form');
        const profileList = document.getElementById('profile-list');
        const profileDisplay = document.getElementById('profile-display');
        const resultsGrid = document.getElementById('results-grid');
        const startCalibrationBtn = document.getElementById('start-calibration-btn');
        const calibrationInstructions = document.getElementById('calibration-instructions');
        const calibrationTaskName = document.getElementById('calibration-task-name');
        const analysisLoaderContainer = document.getElementById('analysis-loader-container');
        const analysisStatusText = document.getElementById('analysis-status-text');
        const redrawLastBtn = document.getElementById('redraw-last-btn');
        const getInDepthAnalysisBtn = document.getElementById('get-in-depth-analysis-btn');
        const inDepthLoader = document.getElementById('in-depth-loader');
        const inDepthContent = document.getElementById('in-depth-content');

        // --- Navigation & Modal ---
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            screens[screenName].classList.add('active');
        }
        function showModal(message, onConfirm) {
            modalMessage.textContent = message;
            modalButtons.innerHTML = ''; // Clear previous buttons

            if (onConfirm) {
                const confirmBtn = document.createElement('button');
                confirmBtn.textContent = 'Confirm';
                confirmBtn.className = 'bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg';
                confirmBtn.onclick = () => {
                    onConfirm();
                    modal.style.display = 'none';
                };
                modalButtons.appendChild(confirmBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg';
                cancelBtn.onclick = () => {
                    modal.style.display = 'none';
                };
                modalButtons.appendChild(cancelBtn);
            } else {
                const okBtn = document.createElement('button');
                okBtn.textContent = 'OK';
                okBtn.className = 'bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-8 rounded-lg';
                okBtn.onclick = () => {
                    modal.style.display = 'none';
                };
                modalButtons.appendChild(okBtn);
            }
            modal.style.display = 'flex';
        }

        // --- Event Listeners ---
        document.getElementById('google-login-btn').addEventListener('click', handleGoogleLogin);
        document.querySelectorAll('.sign-out-btn').forEach(btn => btn.addEventListener('click', handleSignOut));
        document.getElementById('go-to-new-profile-from-dashboard').addEventListener('click', () => showScreen('newProfile'));
        document.getElementById('back-to-dashboard-from-new').addEventListener('click', () => showScreen('dashboard'));
        document.getElementById('back-to-dashboard-from-main').addEventListener('click', () => {
            resetMainScreen();
            showScreen('dashboard');
        });
        document.getElementById('back-to-main-from-report').addEventListener('click', () => showScreen('main'));
        redrawLastBtn.addEventListener('click', handleRedrawLast);
        getInDepthAnalysisBtn.addEventListener('click', handleInDepthAnalysis);


        // --- Initialization & Auth ---
        async function initialize() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        loadProfiles();
                        showScreen('dashboard');
                    } else {
                        userId = null;
                        currentProfile = null;
                        showScreen('login');
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                screens.loading.innerHTML = `<p class="text-red-500">Error: Could not connect to the service.</p>`;
            }
        }

        async function handleGoogleLogin() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google Sign-In Error:", error.code, error.message);
                if (error.code === 'auth/unauthorized-domain') {
                    showModal("Sign-in failed: This app's domain is not authorized. Please add your domain (e.g., localhost or your github.io URL) to the Firebase console under Authentication -> Settings -> Authorized domains.");
                } else {
                    showModal("Could not sign in with Google. Please try again.");
                }
            }
        }

        async function handleSignOut() {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Sign Out Error:", error);
            }
        }
        
        window.onload = () => {
            lucide.createIcons();
            initialize();
        };

        // --- Profile Management ---
        newProfileForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!userId) {
                showModal("You must be signed in to create a profile.");
                return;
            }
            const profileData = {
                name: document.getElementById('name').value,
                sports: document.getElementById('sports').value,
                country: document.getElementById('country').value,
                gender: document.getElementById('gender').value,
                height: parseFloat(document.getElementById('height').value),
                weight: parseFloat(document.getElementById('weight').value),
                shoulderWidth: parseFloat(document.getElementById('shoulderWidth').value),
            };
            try {
                const appId = 'body-measurement-app';
                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/profiles`), profileData);
                currentProfile = { id: docRef.id, ...profileData };
                updateMainScreen();
                showScreen('main');
                newProfileForm.reset();
            } catch (error) {
                console.error("Error adding document: ", error);
                showModal("Failed to save profile. Please ensure your Firestore security rules are set up correctly.");
            }
        });

        async function loadProfiles() {
            if (!userId) return;
            const appId = 'body-measurement-app';
            const profilesCol = collection(db, `artifacts/${appId}/users/${userId}/profiles`);
            const q = query(profilesCol);
            const profileSnapshot = await getDocs(q);
            profileList.innerHTML = '';
            if (profileSnapshot.empty) {
                profileList.innerHTML = '<p class="text-center text-gray-500">No profiles found.</p>';
                return;
            }
            profileSnapshot.forEach((doc) => {
                const profile = { id: doc.id, ...doc.data() };
                const profileElement = document.createElement('div');
                profileElement.className = 'bg-gray-700 p-4 rounded-lg flex justify-between items-center';
                profileElement.innerHTML = `
                    <div class="cursor-pointer flex-grow" data-profile-id="${profile.id}">
                        <p class="font-bold text-lg">${profile.name}</p>
                        <p class="text-sm text-gray-400">${profile.sports || 'N/A'} | ${profile.country || 'N/A'}</p>
                    </div>
                    <button data-delete-id="${profile.id}" class="delete-profile-btn text-red-500 hover:text-red-400 p-2"><i data-lucide="trash-2"></i></button>
                `;
                
                profileElement.querySelector('.cursor-pointer').onclick = () => {
                    currentProfile = profile;
                    updateMainScreen();
                    showScreen('main');
                };

                profileElement.querySelector('.delete-profile-btn').onclick = () => {
                    showModal(`Are you sure you want to delete the profile for ${profile.name}?`, async () => {
                         try {
                            await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/profiles`, profile.id));
                            loadProfiles(); // Refresh the list
                        } catch (error) {
                            console.error("Error deleting profile:", error);
                            showModal("Failed to delete profile. Please ensure your Firestore security rules are set up correctly to allow deletion.");
                        }
                    });
                };

                profileList.appendChild(profileElement);
            });
            lucide.createIcons();
        }

        // --- Main Screen Logic ---
        function updateMainScreen() {
            if (!currentProfile) return;
            profileDisplay.innerHTML = `
                <p><strong>Name:</strong> ${currentProfile.name}</p>
                <p><strong>Sport:</strong> ${currentProfile.sports}</p>
                <p><strong>Country:</strong> ${currentProfile.country}</p>
                <p><strong>Gender:</strong> ${currentProfile.gender}</p>
                <p><strong>Height:</strong> ${currentProfile.height} cm</p>
                <p><strong>Weight:</strong> ${currentProfile.weight} kg</p>
                <p><strong>Shoulder Width:</strong> ${currentProfile.shoulderWidth} cm</p>
            `;
        }
        
        function resetMainScreen() {
            profileDisplay.innerHTML = '';
            ['front', 'side', 'back'].forEach(key => {
                document.getElementById(`${key}-preview`).src = `https://placehold.co/300x400/1F2937/4B5563?text=${key.charAt(0).toUpperCase() + key.slice(1)}+View`;
                document.getElementById(`${key}-image`).value = '';
            });
        }

        function setupImagePreview(inputId, previewId) {
            document.getElementById(inputId).addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        document.getElementById(previewId).src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
        setupImagePreview('front-image', 'front-preview');
        setupImagePreview('side-image', 'side-preview');
        setupImagePreview('back-image', 'back-preview');

        // --- Calibration Logic ---
        const calibrationTasks = [
            { name: 'Draw Height (Top to Bottom)', key: 'front_height', image: 'front' },
            { name: 'Draw Shoulder Width (Bone to Bone)', key: 'front_shoulder_width', image: 'front' },
            { name: 'Draw Height (Top to Bottom)', key: 'side_height', image: 'side' },
            { name: 'Draw Chest Depth (Front to Back)', key: 'side_depth', image: 'side' },
            { name: 'Draw Height (Top to Bottom)', key: 'back_height', image: 'back' },
            { name: 'Draw Shoulder Width (Bone to Bone)', key: 'back_shoulder_width', image: 'back' },
        ];

        function startCalibration() {
            if (!currentProfile) {
                showModal("Please load or create a profile first.");
                return;
            }
            if (!document.getElementById('front-image').files[0] || !document.getElementById('side-image').files[0] || !document.getElementById('back-image').files[0]) {
                showModal("Please upload all three images to begin calibration.");
                return;
            }

            calibrationState = {
                currentIndex: 0,
                lines: {},
                canvases: {
                    front: document.getElementById('front-calibration-canvas'),
                    side: document.getElementById('side-calibration-canvas'),
                    back: document.getElementById('back-calibration-canvas'),
                },
                isDrawing: false,
                startPoint: null,
            };

            setupCalibrationCanvases();
            updateCalibrationInstructions();
            calibrationInstructions.classList.remove('hidden');
        }
        startCalibrationBtn.addEventListener('click', startCalibration);

        function setupCalibrationCanvases() {
            Object.keys(calibrationState.canvases).forEach(key => {
                const canvas = calibrationState.canvases[key];
                const img = document.getElementById(`${key}-preview`);
                
                const resizeCanvas = () => {
                    canvas.width = img.clientWidth;
                    canvas.height = img.clientHeight;
                    redrawLinesForCanvas(key);
                };
                
                new ResizeObserver(resizeCanvas).observe(img);
                if (img.complete) resizeCanvas();

                canvas.onmousedown = (e) => handleCanvasMouseDown(e, key);
                canvas.onmousemove = (e) => handleCanvasMouseMove(e, key);
                canvas.onmouseup = (e) => handleCanvasMouseUp(e, key);
                canvas.onmouseleave = () => { if (calibrationState.isDrawing) { calibrationState.isDrawing = false; redrawLinesForCanvas(key); } };
            });
        }
        
        function updateCalibrationInstructions() {
            redrawLastBtn.style.display = calibrationState.currentIndex > 0 ? 'flex' : 'none';
            if (calibrationState.currentIndex >= calibrationTasks.length) {
                calibrationInstructions.innerHTML = '<p class="text-lg font-semibold text-green-400">Calibration Complete! Generating Report...</p>';
                runAnalysisWithCalibratedRatios();
                return;
            }
            const currentTask = calibrationTasks[calibrationState.currentIndex];
            calibrationTaskName.textContent = currentTask.name;

            Object.values(calibrationState.canvases).forEach(canvas => canvas.classList.remove('active-canvas'));
            calibrationState.canvases[currentTask.image].classList.add('active-canvas');
        }

        function getCanvasCoords(event, canvas) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top,
            };
        }

        function handleCanvasMouseDown(event, imageKey) {
            const currentTask = calibrationTasks[calibrationState.currentIndex];
            if (!currentTask || currentTask.image !== imageKey) return;
            
            calibrationState.isDrawing = true;
            calibrationState.startPoint = getCanvasCoords(event, calibrationState.canvases[imageKey]);
        }

        function handleCanvasMouseMove(event, imageKey) {
            if (!calibrationState.isDrawing) return;
            const currentTask = calibrationTasks[calibrationState.currentIndex];
            if (!currentTask || currentTask.image !== imageKey) return;
            
            const canvas = calibrationState.canvases[imageKey];
            const currentPoint = getCanvasCoords(event, canvas);
            
            redrawLinesForCanvas(imageKey);
            drawLine(canvas, calibrationState.startPoint, currentPoint, true);
        }

        function handleCanvasMouseUp(event, imageKey) {
            if (!calibrationState.isDrawing) return;
            const currentTask = calibrationTasks[calibrationState.currentIndex];
            if (!currentTask || currentTask.image !== imageKey) return;

            calibrationState.isDrawing = false;
            const endPoint = getCanvasCoords(event, calibrationState.canvases[imageKey]);
            calibrationState.lines[currentTask.key] = { start: calibrationState.startPoint, end: endPoint };
            
            redrawLinesForCanvas(imageKey);
            calibrationState.currentIndex++;
            updateCalibrationInstructions();
        }

        function handleRedrawLast() {
            if (calibrationState.currentIndex === 0) return;

            calibrationState.currentIndex--;
            const lastTask = calibrationTasks[calibrationState.currentIndex];
            const imageKeyToClear = lastTask.image;
            delete calibrationState.lines[lastTask.key];

            redrawLinesForCanvas(imageKeyToClear);
            updateCalibrationInstructions();
        }

        function redrawLinesForCanvas(imageKey) {
            const canvas = calibrationState.canvases[imageKey];
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (const key in calibrationState.lines) {
                const task = calibrationTasks.find(t => t.key === key);
                if (task.image === imageKey) {
                    const line = calibrationState.lines[key];
                    drawLine(canvas, line.start, line.end);
                }
            }
        }

        function drawLine(canvas, start, end, isTemporary = false) {
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = isTemporary ? 'rgba(79, 70, 229, 0.9)' : 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
        }

        async function runAnalysisWithCalibratedRatios() {
            analysisLoaderContainer.classList.remove('hidden');
            startCalibrationBtn.disabled = true;
            analysisStatusText.textContent = "Locating measurement points...";

            try {
                // Calculate ratios safely, checking for zero pixel length
                const getRatio = (realCm, pixelLine) => {
                    const pixelLength = Math.sqrt(Math.pow(pixelLine.start.x - pixelLine.end.x, 2) + Math.pow(pixelLine.start.y - pixelLine.end.y, 2));
                    return pixelLength > 0 ? realCm / pixelLength : 0;
                };

                const ratios = {
                    front_y_ratio: getRatio(currentProfile.height, calibrationState.lines.front_height),
                    front_x_ratio: getRatio(currentProfile.shoulderWidth, calibrationState.lines.front_shoulder_width),
                    side_y_ratio: getRatio(currentProfile.height, calibrationState.lines.side_height),
                    side_z_ratio: getRatio(currentProfile.shoulderWidth * 0.5, calibrationState.lines.side_depth), // Approximation for chest depth
                    back_y_ratio: getRatio(currentProfile.height, calibrationState.lines.back_height),
                    back_x_ratio: getRatio(currentProfile.shoulderWidth, calibrationState.lines.back_shoulder_width),
                };
                
                const coordinates = await getAiCoordinates();
                if (!coordinates) {
                    showModal("The AI could not identify measurement points on the images. Please try again with clearer, well-lit photos.");
                    throw new Error("AI coordinate identification failed.");
                }

                analysisStatusText.textContent = "Calculating measurements...";
                const measurements = calculateMeasurements(coordinates, ratios);
                lastCalculatedMeasurements = measurements; // Save for in-depth analysis

                displayBasicReport(measurements);
                showScreen('report');

            } catch (error) {
                 console.error("Analysis with ratios failed:", error);
                 showModal("An unexpected error occurred during the final analysis.");
            } finally {
                analysisLoaderContainer.classList.add('hidden');
                startCalibrationBtn.disabled = false;
                calibrationInstructions.classList.add('hidden');
                 Object.values(calibrationState.canvases).forEach(canvas => {
                    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                    canvas.classList.remove('active-canvas');
                 });
            }
        }

        // --- AI & Calculation Functions ---

        // FIXED: Added the missing image processing function
        function resizeAndEncodeImage(file, maxWidth = 512, maxHeight = 512) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;

                        if (width > height) {
                            if (width > maxWidth) {
                                height *= maxWidth / width;
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width *= maxHeight / height;
                                height = maxHeight;
                            }
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        const dataUrl = canvas.toDataURL(file.type);
                        const base64 = dataUrl.split(',')[1];
                        
                        resolve({ mimeType: file.type, base64: base64 });
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async function getAiCoordinates() {
            const prompt = `Your task is to identify the pixel coordinates of specific anatomical landmarks on the three provided body images (front, side, back). Return ONLY a valid JSON object with the coordinates. The required points are: shoulder_left, shoulder_right, chest_left, chest_right, chest_front, chest_back, waist_left, waist_right, waist_front, waist_back, hip_left, hip_right, hip_front, hip_back. Example for a point: "shoulder_left": {"x": 150, "y": 200}.`;
            
            const [frontData, sideData, backData] = await Promise.all([
                resizeAndEncodeImage(document.getElementById('front-image').files[0]),
                resizeAndEncodeImage(document.getElementById('side-image').files[0]),
                resizeAndEncodeImage(document.getElementById('back-image').files[0])
            ]);

            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: frontData.mimeType, data: frontData.base64 } },
                        { inlineData: { mimeType: sideData.mimeType, data: sideData.base64 } },
                        { inlineData: { mimeType: backData.mimeType, data: backData.base64 } }
                    ]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    temperature: 0,
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent?key=${GEMINI_API_KEY}`;
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (response.ok) {
                    const result = await response.json();
                    if (result.candidates && result.candidates[0]?.content?.parts?.[0]) {
                       const jsonText = result.candidates[0].content.parts[0].text;
                       return JSON.parse(jsonText);
                    }
                } else {
                     const errorText = await response.text();
                     console.error(`Coordinate API Error:`, response.status, errorText);
                     if (errorText.includes("API key not valid")) {
                        showModal("API Key Error: The provided Gemini API key is not valid. Please check the key in the code.");
                     }
                }
            } catch (error) {
                console.error(`Coordinate Fetch error:`, error);
            }
            return null;
        }

        // FIXED: Made calculations more robust with optional chaining (?.)
        function calculateMeasurements(coords, ratios) {
            const measurements = {};
            const pi = Math.PI;

            const getCircumference = (widthCm, depthCm) => {
                if (!widthCm || !depthCm || widthCm <= 0 || depthCm <= 0) return 0;
                // Ramanujan's approximation for the circumference of an ellipse
                return pi * (3 * (widthCm + depthCm) - Math.sqrt((3 * widthCm + depthCm) * (widthCm + 3 * depthCm))) / 2;
            };

            const shoulder_width_px = Math.abs((coords?.shoulder_left?.x || 0) - (coords?.shoulder_right?.x || 0));
            measurements["Shoulder Width"] = shoulder_width_px * ratios.front_x_ratio;

            const chest_width_px = Math.abs((coords?.chest_left?.x || 0) - (coords?.chest_right?.x || 0));
            const chest_depth_px = Math.abs((coords?.chest_front?.x || 0) - (coords?.chest_back?.x || 0));
            const chest_width_cm = chest_width_px * ratios.front_x_ratio;
            const chest_depth_cm = chest_depth_px * ratios.side_z_ratio;
            measurements["Chest"] = getCircumference(chest_width_cm, chest_depth_cm);

            const waist_width_px = Math.abs((coords?.waist_left?.x || 0) - (coords?.waist_right?.x || 0));
            const waist_depth_px = Math.abs((coords?.waist_front?.x || 0) - (coords?.waist_back?.x || 0));
            const waist_width_cm = waist_width_px * ratios.front_x_ratio;
            const waist_depth_cm = waist_depth_px * ratios.side_z_ratio;
            measurements["Waist"] = getCircumference(waist_width_cm, waist_depth_cm);

            const hip_width_px = Math.abs((coords?.hip_left?.x || 0) - (coords?.hip_right?.x || 0));
            const hip_depth_px = Math.abs((coords?.hip_front?.x || 0) - (coords?.hip_back?.x || 0));
            const hip_width_cm = hip_width_px * ratios.front_x_ratio;
            const hip_depth_cm = hip_depth_px * ratios.side_z_ratio;
            measurements["Hip"] = getCircumference(hip_width_cm, hip_depth_cm);

            return measurements;
        }

        async function getAiPhysiqueAnalysis(measurements) {
            const prompt = `Given the following body measurements for a ${currentProfile.gender}, analyze the physique to determine the somatotype (body type) and provide sports recommendations. Return ONLY a valid JSON object with 'bodyType' ({ "type": "...", "description": "..." }) and 'sportsRecommendation' ({ "recommended": ["..."], "caution": ["..."] }) keys.

            Measurements:
            ${JSON.stringify(measurements, null, 2)}
            `;
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    temperature: 0.2,
                }
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${GEMINI_API_KEY}`;
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (response.ok) {
                    const result = await response.json();
                    if (result.candidates && result.candidates[0]?.content?.parts?.[0]) {
                       const jsonText = result.candidates[0].content.parts[0].text;
                       return JSON.parse(jsonText);
                    }
                } else {
                     console.error(`Analysis API Error:`, response.status, await response.text());
                }
            } catch (error) {
                console.error(`Analysis Fetch error:`, error);
            }
            return null;
        }
        
        async function handleInDepthAnalysis() {
            if (!lastCalculatedMeasurements) return;
            getInDepthAnalysisBtn.classList.add('hidden');
            inDepthLoader.classList.remove('hidden');

            const analysis = await getAiPhysiqueAnalysis(lastCalculatedMeasurements);
            if (analysis && analysis.bodyType && analysis.sportsRecommendation) {
                document.getElementById('body-type-title').textContent = analysis.bodyType.type;
                document.getElementById('body-type-description').textContent = analysis.bodyType.description;

                const recommendedList = document.getElementById('recommended-sports-list');
                recommendedList.innerHTML = analysis.sportsRecommendation.recommended.map(sport => `<li>${sport}</li>`).join('');
                const cautionList = document.getElementById('caution-sports-list');
                cautionList.innerHTML = analysis.sportsRecommendation.caution.map(sport => `<li>${sport}</li>`).join('');
                inDepthContent.classList.remove('hidden');
            } else {
                showModal("Could not generate the in-depth analysis at this time.");
                getInDepthAnalysisBtn.classList.remove('hidden');
            }
            inDepthLoader.classList.add('hidden');
        }

        function displayBasicReport(measurements) {
            resultsGrid.innerHTML = '';
            for (const [key, value] of Object.entries(measurements)) {
                const resultItem = document.createElement('div');
                resultItem.className = 'bg-gray-800 p-4 rounded-lg';
                resultItem.innerHTML = `<p class="text-sm text-gray-400">${key}</p><p class="text-2xl font-bold">${Number(value).toFixed(1)} <span class="text-base font-normal text-gray-500">cm</span></p>`;
                resultsGrid.appendChild(resultItem);
            }
            // Reset and hide the in-depth section for the new report
            inDepthContent.classList.add('hidden');
            getInDepthAnalysisBtn.classList.remove('hidden');
        }

    </script>
</body>
</html>
```